<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <title>P5 Sketch</title>
</head>
<body>
    <script>
        let particles = [];
        let circleRadius = 80;
        let baseSize = 2.5;
        let avoidanceRadius = 50;
        let isMousePressed = false;
        let numParticles;
        let gridCenters = [];

        function setup() {
            createCanvas(windowWidth, windowHeight);
            colorMode(HSB, 255);

            let circleArea = PI * circleRadius * circleRadius;
            let particleArea = PI * (baseSize / 2) * (baseSize / 2);
            numParticles = Math.floor((circleArea / 50) / particleArea);

            let startX = 200;
            let startY = 100;
            let gap = circleRadius * 2.5;

            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 5; col++) {
                    if (row === 2 && col === 4) continue;
                    let x = startX + col * gap;
                    let y = startY + row * gap;
                    gridCenters.push({ x, y });

                    for (let i = 0; i < numParticles; i++) {
                        let angle = random(TWO_PI);
                        let r = random(circleRadius * 0.5, circleRadius);
                        let px = x + r * cos(angle);
                        let py = y + r * sin(angle);
                        particles.push(new Particle(px, py, x, y));
                    }
                }
            }
        }

        function draw() {
            background(0);

            textSize(16);
            textAlign(CENTER, CENTER);
            fill(255);
            noStroke();
            for (let i = 0; i < gridCenters.length; i++) {
                let center = gridCenters[i];
                noFill();
                ellipse(center.x, center.y, circleRadius * 2);
                fill(255);
                text(i + 1, center.x, center.y - circleRadius - 10);
            }

            if (mouseX >= 0 && mouseY >= 0 && mouseX <= width && mouseY <= height) {
                noStroke();
                let cursorColor = isMousePressed ? color(200, 100, 255, 50) : color(120, 20, 20, 20);
                fill(cursorColor);
                ellipse(mouseX, mouseY, avoidanceRadius * 2);
            }

            for (let p of particles) {
                p.applyBehaviors(mouseX, mouseY);
                p.update();
                p.display();
            }
        }

        function mousePressed() {
            isMousePressed = true;
        }

        function mouseReleased() {
            isMousePressed = false;
        }

        class Particle {
            constructor(x, y, cx, cy) {
                this.pos = createVector(x, y);
                this.vel = p5.Vector.random2D().mult(2);
                this.acc = createVector(0, 0);
                this.color = color(255);
                this.maxSpeed = 1;
                this.circleCenter = createVector(cx, cy);
            }

            applyBehaviors(cursorX, cursorY) {
                let force;
                if (isMousePressed) {
                    force = this.attractToCursor(cursorX, cursorY);
                } else {
                    force = this.avoidCursor(cursorX, cursorY);
                }
                let stayForce = this.stayInsideCircle();
                this.applyForce(force);
                this.applyForce(stayForce);
            }

            attractToCursor(cursorX, cursorY) {
                let cursor = createVector(cursorX, cursorY);
                let toCursor = p5.Vector.sub(cursor, this.pos);
                let d = toCursor.mag();

                if (d < avoidanceRadius) {
                    toCursor.setMag(map(d, 0, avoidanceRadius, this.maxSpeed, 0.5));
                    return toCursor;
                }
                return createVector(0, 0);
            }

            avoidCursor(cursorX, cursorY) {
                let cursor = createVector(cursorX, cursorY);
                let d = dist(this.pos.x, this.pos.y, cursor.x, cursor.y);

                if (d < avoidanceRadius) {
                    let flee = p5.Vector.sub(this.pos, cursor);
                    flee.setMag(map(d, 0, avoidanceRadius, this.maxSpeed, 0));
                    return flee;
                }
                return createVector(0, 0);
            }

            stayInsideCircle() {
                let d = dist(this.pos.x, this.pos.y, this.circleCenter.x, this.circleCenter.y);

                if (d > circleRadius) {
                    let toCenter = p5.Vector.sub(this.circleCenter, this.pos);
                    toCenter.setMag(1);
                    return toCenter;
                }
                return createVector(0, 0);
            }

            applyForce(force) {
                this.acc.add(force);
            }

            update() {
                this.vel.add(this.acc);
                this.vel.limit(this.maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
            }

            display() {
                noStroke();
                fill(this.color);
                ellipse(this.pos.x, this.pos.y, baseSize);
            }
        }
    </script>
</body>
</html>
